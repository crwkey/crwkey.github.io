<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.110.0"><meta name=viewport content="width=device-width,initial-scale=1"><script async src="https://www.googletagmanager.com/gtag/js?id=G-CHP0LWG5GF"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-CHP0LWG5GF")</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2009162505910536" crossorigin=anonymous></script><title>Rust 内存管理 &#183; rwkey</title><meta name=description content><link type=text/css rel=stylesheet href=https://rwkey.com/css/print.css media=print><link type=text/css rel=stylesheet href=https://rwkey.com/css/poole.css><link type=text/css rel=stylesheet href=https://rwkey.com/css/syntax.css><link type=text/css rel=stylesheet href=https://rwkey.com/css/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png></head><body><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://rwkey.com/><h1>rwkey</h1></a><p class=lead>北漂码农</p></div><nav><ul class=sidebar-nav><li><a href=https://rwkey.com/>Home</a></li><li><a href=https://github.com/crwkey/>Github</a></li></ul></nav><p>&copy; 2023. All rights reserved.</p></div></aside><main class="content container"><div class=post><h1>Rust 内存管理</h1><time datetime=2021-03-11T20:55:20+0800 class=post-date>Thu, Mar 11, 2021</time><p>Rust 在编译期间，通过静态分析，确定对象的作用域与生命周期，从而可以确定某个对象不再被使用，将其销毁，并且不会引入任何运行时的开销。</p><h5 id=值类型与引用类型>值类型与引用类型</h5><p>在 rust 中， 实现 Copy 这个 trait，用来标记一个值类型，另外一种就是数据分配在堆上，实际内容是一个内存地址，指向栈上的实际数据，记住只有堆上的数据才需要进行内存管理。</p><h4 id=copy-语义>copy 语义</h4><p>默认实现了 Copy 类型的：
整形，浮点型，布尔型，字符型, &T 都是实现了 Copy trait，元组类型，如果元组里面所有类型都实现了 Copy trait，那么这个元组也就实现了 Copyt trait，数组同理</p><p>需要手动实现 Copy 类型的
对于 Rust 结构体，枚举，如果他们内部都实现了 Copy trait，则他们可以手动实现 Copy trait。</p><p>无法实现 Copy 类型
Box 就是无法实现 Copy 类型，原因是因为如果 Box 实现了 Copy，那么就会有多次释放问题，还有可变借用指针类型 &mut T， String, 对于这类可以通过调用 clone 方法解决</p><h5 id=move-语义>move 语义</h5><p>赋值，函数传参，返回值，match 这四个操作，如果是针对一个值类型的话，相当于把这个值赋值到目标上，原来值的修改不会影响到新的值。举个例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#ff79c6>fn</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span>   <span style=color:#8be9fd;font-style:italic>let</span> num1 <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>   <span style=color:#8be9fd;font-style:italic>let</span> num2 <span style=color:#ff79c6>=</span> num1;
</span></span><span style=display:flex><span>   println!(<span style=color:#f1fa8c>&#34;num1={}, num2={}&#34;</span>, num1, num2);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果换做是一个引用类型的话，执行上面的操作会怎么样？比如我们用 String 为例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#ff79c6>fn</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span>   <span style=color:#8be9fd;font-style:italic>let</span> s1 <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>String</span>::from(<span style=color:#f1fa8c>&#34;rwkey.com&#34;</span>);
</span></span><span style=display:flex><span>   <span style=color:#8be9fd;font-style:italic>let</span> s2 <span style=color:#ff79c6>=</span> s1;
</span></span><span style=display:flex><span>   println!(<span style=color:#f1fa8c>&#34;s1={}, s2={}&#34;</span>, s1, s2);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>此时我们会看到一个编译错误：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>error<span style=color:#ff79c6>[</span>E0382<span style=color:#ff79c6>]</span>: borrow of moved value: <span style=color:#f1fa8c>`</span>s1<span style=color:#f1fa8c>`</span>
</span></span><span style=display:flex><span> --&gt; src/main.rs:4:29
</span></span><span style=display:flex><span>  |
</span></span><span style=display:flex><span><span style=color:#bd93f9>2</span> |    <span style=color:#8be9fd;font-style:italic>let</span> <span style=color:#8be9fd;font-style:italic>s1</span> <span style=color:#ff79c6>=</span> String::from<span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;rwkey.com&#34;</span><span style=color:#ff79c6>)</span>;
</span></span><span style=display:flex><span>  |        -- move occurs because <span style=color:#f1fa8c>`</span>s1<span style=color:#f1fa8c>`</span> has <span style=color:#8be9fd;font-style:italic>type</span> <span style=color:#f1fa8c>`</span>String<span style=color:#f1fa8c>`</span>, which does not implement the <span style=color:#f1fa8c>`</span>Copy<span style=color:#f1fa8c>`</span> trait
</span></span><span style=display:flex><span><span style=color:#bd93f9>3</span> |    <span style=color:#8be9fd;font-style:italic>let</span> <span style=color:#8be9fd;font-style:italic>s2</span> <span style=color:#ff79c6>=</span> s1;
</span></span><span style=display:flex><span>  |             -- value moved here
</span></span><span style=display:flex><span><span style=color:#bd93f9>4</span> |    println!<span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;s1={}, s2={}&#34;</span>, s1, s2<span style=color:#ff79c6>)</span>;
</span></span><span style=display:flex><span>  |                             ^^ value borrowed here after move
</span></span></code></pre></div><p>原因是执行 <code>let s2 = s1</code> 语句时，不是将 s1 的内容复制一份给 s2，而是将数据「移动」到了新的变量，原来的变量不能再使用。这样我们就能确保堆上分配的内存都只有唯一的拥有者。</p><h5 id=借用>借用</h5><p>我们下面来看一个引用的例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#ff79c6>fn</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span>   <span style=color:#8be9fd;font-style:italic>let</span> s1 <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>String</span>::from(<span style=color:#f1fa8c>&#34;rwkey.com&#34;</span>);
</span></span><span style=display:flex><span>   <span style=color:#8be9fd;font-style:italic>let</span> len <span style=color:#ff79c6>=</span> str_len(s1);
</span></span><span style=display:flex><span>   println!(<span style=color:#f1fa8c>&#34;s1={}, len={}&#34;</span>, s1, len);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>fn</span> <span style=color:#50fa7b>str_len</span>(<span style=color:#8be9fd>str</span>: <span style=color:#8be9fd;font-style:italic>String</span>) -&gt; <span style=color:#8be9fd>usize</span> {
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>return</span> <span style=color:#8be9fd>str</span>.len();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>此时我们会看到一个编译错误：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>error<span style=color:#ff79c6>[</span>E0382<span style=color:#ff79c6>]</span>: borrow of moved value: <span style=color:#f1fa8c>`</span>s1<span style=color:#f1fa8c>`</span>
</span></span><span style=display:flex><span> --&gt; src/main.rs:4:30
</span></span><span style=display:flex><span>  |
</span></span><span style=display:flex><span><span style=color:#bd93f9>2</span> |    <span style=color:#8be9fd;font-style:italic>let</span> <span style=color:#8be9fd;font-style:italic>s1</span> <span style=color:#ff79c6>=</span> String::from<span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;rwkey.com&#34;</span><span style=color:#ff79c6>)</span>;
</span></span><span style=display:flex><span>  |        -- move occurs because <span style=color:#f1fa8c>`</span>s1<span style=color:#f1fa8c>`</span> has <span style=color:#8be9fd;font-style:italic>type</span> <span style=color:#f1fa8c>`</span>String<span style=color:#f1fa8c>`</span>, which does not implement the <span style=color:#f1fa8c>`</span>Copy<span style=color:#f1fa8c>`</span> trait
</span></span><span style=display:flex><span><span style=color:#bd93f9>3</span> |    <span style=color:#8be9fd;font-style:italic>let</span> <span style=color:#8be9fd;font-style:italic>len</span> <span style=color:#ff79c6>=</span> str_len<span style=color:#ff79c6>(</span>s1<span style=color:#ff79c6>)</span>;
</span></span><span style=display:flex><span>  |                      -- value moved here
</span></span><span style=display:flex><span><span style=color:#bd93f9>4</span> |    println!<span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;s1={}, len={}&#34;</span>, s1, len<span style=color:#ff79c6>)</span>;
</span></span><span style=display:flex><span>  |                              ^^ value borrowed here after move
</span></span></code></pre></div><p>原因是 s1 被当作参数传入了 str_len 这个函数，根据 move 规则，s1 就失效了，后面的 println！宏调用如果要再次使用 s1 就会发生错误，如果是这样那就太不方便使用了，于是 rust 引入了借用概念，只要在变量或类型前面加 & 前缀即可。我们对上面的代码进行改造：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#ff79c6>fn</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span>   <span style=color:#8be9fd;font-style:italic>let</span> s1 <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>String</span>::from(<span style=color:#f1fa8c>&#34;rwkey.com&#34;</span>);
</span></span><span style=display:flex><span>   <span style=color:#8be9fd;font-style:italic>let</span> len <span style=color:#ff79c6>=</span> str_len(<span style=color:#ff79c6>&amp;</span>s1);
</span></span><span style=display:flex><span>   println!(<span style=color:#f1fa8c>&#34;s1={}, len={}&#34;</span>, s1, len);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>fn</span> <span style=color:#50fa7b>str_len</span>(<span style=color:#8be9fd>str</span>: <span style=color:#ff79c6>&amp;</span><span style=color:#8be9fd;font-style:italic>String</span>) -&gt; <span style=color:#8be9fd>usize</span> {
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>return</span> <span style=color:#8be9fd>str</span>.len();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面的代码可以编译通过，通过 & 操作符号，之前的 move 语义操作变成了 borrow 操作，但是对象的生命周期不会转移，只是暂时借到了新的地方。</p><h5 id=借用的可变性>借用的可变性</h5><p>借用规则：</p><ol><li>多次只读借用</li><li>一次可变借用</li><li>读借用不能和可变借用共存</li><li>可变借用必须是拥有者可变</li></ol><h5 id=生命周期>生命周期</h5><p>生命周期是 rust 在编译时对借用的返回值生命周期的无法判断，需要手动指定参数和返回值的生命周期, 用一个 &rsquo; 加一个字母表示，比如<code>'a</code></p></div></main><script async src="https://www.googletagmanager.com/gtag/js?id=G-CHP0LWG5GF"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-CHP0LWG5GF")</script></body></html>